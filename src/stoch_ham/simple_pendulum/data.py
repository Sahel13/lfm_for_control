import jax
import jax.random as random
import jax.numpy as jnp
import matplotlib.pyplot as plt
from stoch_ham.sde import euler_maruyama


def hamiltonian(x, params):
    """
    The Hamiltonian of the simple pendulum.
    :param x: The state.
    :param params: The parameters of the system.
    :return: The Hamiltonian.
    """
    q, p = x
    m, l = params['mass'], params['length']
    return p ** 2 / (2 * m * l ** 2) + m * 9.81 * l * (1 - jnp.cos(q))


def drift_fn(x, params):
    """
    The drift function of the stochastic Hamiltonian system.
    :param x: The state.
    :param params: The parameters of the system.
    :return: The drift vector field.
    """
    q, p = x
    g = 9.81
    m, l = params['mass'], params['length']
    return jnp.array([p / (m * l ** 2), -m * g * l * jnp.sin(q)])


def diffusion_fn(x, params):
    """
    The diffusion function of the stochastic Hamiltonian system.
    :param x: The state.
    :param params: The parameters of the system.
    :return: The diffusion vector field.
    """
    return jnp.array([0., 1.])


def generate_measurements(key, true_traj, meas_error, sampling_rate, dt):
    """
    Given a trajectory generated by an SDE solver, generate measurements with a
    frequency given by `sampling_rate` and add Gaussian measurement noise.
    :param key: JAX random key.
    :param true_traj: A trajectory generated by an SDE solver.
    :param meas_error: Standard deviations of measurement noise for each coordinate.
    :param sampling_rate: Number of measurements per second.
    :param dt: Time step of the SDE solver.
    :return:
    """
    # Get trajectory values according to the sampling rate.
    step = int(1 / (sampling_rate * dt))
    sub_traj = true_traj[::step]
    # Add noise
    meas_noise = random.normal(key, shape=sub_traj.shape) * meas_error
    meas_sub_traj = sub_traj + meas_noise
    return sub_traj, meas_sub_traj


def get_dataset(
        key,
        num_trajectories,
        params,
        x0,
        t_span,
        dt: float = 0.001,
        sampling_rate: int = 100):
    """
    Function to generate a dataset of trajectories of the simple pendulum.
    :return: A list of trajectories.
    """
    dataset = []
    for i in range(num_trajectories):
        key, subkey = random.split(key)
        soln = euler_maruyama(subkey, drift_fn, diffusion_fn, params, x0, t_span, dt)

        key, subkey = random.split(key)
        true, meas = generate_measurements(subkey, soln, params['meas_error'], sampling_rate, dt)

        dataset.append((true, meas))
    return dataset


# Example usage and visualization.
if __name__ == "__main__":
    seed = 12
    key = random.PRNGKey(seed)

    params = {
        'mass': 1.,
        'length': 2.,
        'lambda': 5.,
        'q': 0.05,
        'meas_error': jnp.array([0.1, .5])
    }

    x0 = jnp.array([jnp.pi / 2, 0.])
    t_span = (0., 10.)

    trajs = get_dataset(key, 5, params, x0, t_span)

    ts = jnp.linspace(*t_span, len(trajs[0]))

    plt.figure()
    for traj in trajs:
        plt.plot(traj[:, 0], traj[:, 1])
    plt.xlabel(r"$q$")
    plt.ylabel(r"$p$")
    plt.title("Phase space trajectory")
    plt.show()

    plt.figure()
    for traj in trajs:
        plt.plot(ts, traj[:, 0], label=r"$q$")
        plt.plot(ts, traj[:, 1], label=r"$p$")
    plt.title("Trajectory")
    plt.xlabel("Time")
    plt.legend()
    plt.show()

    energies = jax.vmap(hamiltonian, in_axes=(0, None))(trajs[0], params)
    plt.figure()
    plt.plot(ts, energies)
    plt.title("Energy vs time")
    plt.xlabel("Time")
    plt.ylabel("Energy")
    plt.show()
