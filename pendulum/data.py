import jax.random as random
import jax.numpy as jnp
from stoch_ham.sde import euler_maruyama


def hamiltonian(x, params):
    """
    The Hamiltonian of the simple pendulum.
    :param x: The state.
    :param params: The parameters of the system.
    :return: The Hamiltonian.
    """
    q, p = x
    g = 9.81
    m, l = params['mass'], params['length']
    return p ** 2 / (2 * m * l ** 2) + m * g * l * (1 - jnp.cos(q))


def _default_drift_fn(x, t, params):
    """
    The dynamics of the simple pendulum.
    :param x: The state.
    :param params: The parameters of the system.
    :return: The drift vector field.
    """
    q, p = x
    g = 9.81
    m, l = params['mass'], params['length']
    return jnp.array([p / (m * l ** 2), -m * g * l * jnp.sin(q)])


def _default_diffusion_fn(x, t, params):
    """
    The diffusion function of the stochastic Hamiltonian system.
    :param x: The state.
    :param params: The parameters of the system.
    :return: The diffusion vector field.
    """
    return jnp.array([0., 1.])


def add_meas_noise(key, true_traj, meas_error):
    """
    Add Gaussian measurement noise to a trajectory.
    :param key: JAX random key.
    :param true_traj: The noise-free trajectory with shape [num_time_points, state_dim].
    :param meas_error: Array of standard deviations for each state dimension.
    :return: Trajectory with noise.
    """
    meas_noise = random.normal(key, shape=true_traj[1:].shape) * meas_error
    meas_traj = true_traj[1:] + meas_noise
    return meas_traj



def generate_measurements(key, true_traj, meas_error, sampling_rate, dt):
    """
    Given a trajectory generated by an SDE solver, generate measurements with a
    frequency given by `sampling_rate` and add Gaussian measurement noise.
    :param key: JAX random key.
    :param true_traj: A trajectory generated by an SDE solver.
    :param meas_error: Standard deviations of measurement noise for each coordinate.
    :param sampling_rate: Number of measurements per second.
    :param dt: Time step of the SDE solver.
    :return: The true trajectory and the noisy measurements at `sampling_rate` frequency.
    """
    # Get trajectory values according to the sampling rate.
    step = int(1 / (sampling_rate * dt))
    sub_traj = true_traj[::step]
    # Add noise
    meas_traj = add_meas_noise(key, sub_traj, meas_error)
    return sub_traj, meas_traj


def get_dataset(
        key,
        params,
        x0,
        t_span,
        meas_error,
        drift_fn=_default_drift_fn,
        diffusion_fn=_default_diffusion_fn,
        dt: float = 0.001,
        sampling_rate: int = 10):
    """
    Generate a trajectory of the simple pendulum.
    """
    # Simulate the system.
    key, subkey = random.split(key)
    soln = euler_maruyama(subkey, drift_fn, diffusion_fn, params, x0, t_span, dt)

    # Sample the trajectory and generate measurements.
    key, subkey = random.split(key)
    true, meas = generate_measurements(subkey, soln, meas_error, sampling_rate, dt)

    return true, meas
